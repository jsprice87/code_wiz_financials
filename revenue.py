import pandas as pd
import random
from dateutil.relativedelta import relativedelta
from datetime import datetime

def add_revenue(df, name, date, amount):
    """
    Add a unique revenue to the dataframe.
    
    Args:
    - df (pd.DataFrame): The dataframe to which the revenue should be added.
    - name (str): Name of the revenue.
    - date (str or datetime): Date of the revenue.
    - amount (float): Amount of the revenue.
    
    Returns:
    - pd.DataFrame: Updated dataframe with the new revenue.
    """
    new_revenue = pd.DataFrame({
        'Date': [date],
        'Name': [name],
        'Amount': [amount]
    })
    return pd.concat([df, new_revenue], ignore_index=True)


def add_birthday_party(df, start_date, end_date, value):
    # Convert dates to integer timestamps
    start_timestamp = int(start_date.timestamp())
    end_timestamp = int(end_date.timestamp())
    
    # Generate a random timestamp between the start and end dates
    random_timestamp = random.randint(start_timestamp, end_timestamp)
    
    # Convert the random timestamp back to a datetime object
    random_date = datetime.fromtimestamp(random_timestamp)
    
    add_revenue(df, "Birthday Party", random_date, value)

    return df

    
# Revenue model definition
def revenue_growth_df(initial_students, revenue_per_student, growth_rate, max_students, start_date, end_date):
    """
    Generates a dataframe of recurring revenues based on the given parameters.
    
    Parameters:
    - initial_students (int): The starting number of students.
    - revenue_per_customer (float): The revenue generated by each customer.
    - growth_rate (float): The month-to-month growth rate of students.
    - max_students (int): The maximum number of students.
    - start_date (datetime): The starting date for the revenue generation.
    - end_date (datetime): The ending date for the revenue generation.
    
    Returns:
    - DataFrame: A DataFrame containing the recurring revenues.
    """

    # List to hold the data for each month
    revenue_data = []
    
    current_students = initial_students
    while start_date <= end_date:
        monthly_revenue = current_students * revenue_per_student
        revenue_data.append({'Date': start_date, 
                             'Name': "Enrollment Revenue",
                             'Amount': monthly_revenue,
                             'Student_Count': current_students})
                             
        
        # Calculate the number of students for the next month
        current_students = min(current_students * (1 + growth_rate), max_students)
        
        # Increment the month
        start_date += relativedelta(months=1)

    # Convert the list of dictionaries into a DataFrame
    revenue_df = pd.DataFrame(revenue_data)

    return revenue_df

def combine_revenue(recurring_revenue_df, unique_revenue_df):
    """
    Combines the unique and recurring revenues into a single DataFrame.
    
    Parameters:
    - recurring_revenue_df (DataFrame): The DataFrame containing recurring revenues.
    - unique_revenue_df (DataFrame): The DataFrame containing unique revenues.
    
    Returns:
    - DataFrame: A DataFrame containing the combined revenues.
    """

    # Concatenate both DataFrames
    combined_revenues = pd.concat([recurring_revenue_df, unique_revenue_df], ignore_index=True)

    # Ensure the 'Date' column is of type Timestamp
    combined_revenues['Date'] = pd.to_datetime(combined_revenues['Date']) 

    return combined_revenues.sort_values(by='Date')
import pandas as pd

def pad_revenues(expenses_df, revenues_df):
    """
    Pad the revenues DataFrame with zeros for months when there's no revenue, ensuring it aligns with the expenses DataFrame.

    Parameters:
    - expenses_df (DataFrame): The expenses dataframe.
    - revenues_df (DataFrame): The revenues dataframe.

    Returns:
    - DataFrame: Padded revenues dataframe.
    """

    # Find the minimum date in the expenses dataframe
    min_date = expenses_df['Date'].min()

    # If the minimum date in the revenues dataframe is later than the minimum date in the expenses dataframe,
    # we need to pad the revenues dataframe with zeros for the missing months.
    if revenues_df['Date'].min() > min_date:
        start_date = min_date
        end_date = revenues_df['Date'].min() - pd.Timedelta(days=1)  # One day before the revenue starts

        # Create a range of dates for which we want to pad the revenues dataframe with zeros
        date_range = pd.date_range(start_date, end_date, freq='M')  # This creates a range of month-end dates

        # Create a dataframe with zeros for the missing months
        padding_df = pd.DataFrame({
            'Date': date_range,
            'Revenue_Name': 'Enrollment Revenue',
            'Amount': 0
        })

        # Concatenate the padding dataframe with the revenues dataframe
        revenues_df = pd.concat([padding_df, revenues_df], ignore_index=True).sort_values(by='Date')

    return revenues_df
